# FPGA AI 개발 도구 - 기술 개요

## 1. 핵심 기술: Graph RAG

### 1.1 Graph RAG란?
- **정의**: 텍스트를 그래프 구조로 변환하여 관련 정보만 선택적으로 검색하는 RAG 변형
- **기존 RAG와의 차이**:
  - 기존 RAG: 텍스트 청크 단위로 유사도 검색
  - Graph RAG: 엔티티와 관계를 그래프로 모델링, 구조적 탐색

### 1.2 왜 코드에 적합한가?
Graph RAG는 원래 **텍스트보다 코드에 더 적합**:
- 코드는 본질적으로 그래프 구조 (함수 호출, 클래스 상속, 모듈 의존성)
- 명확한 엔티티와 관계
- 구조적 정보 활용 가능

### 1.3 소프트웨어에서 실패한 이유
- **더러운 구성**: 레거시 코드, 스파게티 코드
- **동적 변화**: 런타임에 구조 변경 (동적 로딩, 리플렉션)
- **복잡한 생태계**: 수많은 프레임워크와 라이브러리
- **커스터마이징**: 개발자마다 다른 스타일과 패턴

**예외적 성공 사례**: Magic AI Wingman

### 1.4 하드웨어에서 유리한 이유
| 특성 | 소프트웨어 | 하드웨어 (FPGA) |
|------|----------|----------------|
| 구조 | 동적 | **정적** ✅ |
| 변경 | 런타임 변경 가능 | **회로는 불변** ✅ |
| 종속성 | 복잡, 순환 참조 | **명확, 계층적** ✅ |
| 파싱 | 어려움 (동적 요소) | **쉬움** ✅ |
| 표준화 | 낮음 | **높음** ✅ |

## 2. 컨텍스트 압축 전략

### 2.1 문제 정의
FPGA 프로젝트를 AI에 전달하려면:
- 코드 (.v, .sv)
- 제약 파일 (XDC)
- 블록 디자인 (BD)
- 타이밍 리포트 (.rpt)
- 합성/구현 결과

→ **파일 용량 비대** → 딜레이 증가 + 토큰 소비 증가

### 2.2 목표
- ✅ 많은 정보를 정확하게 전달
- ✅ 적은 용량
- ✅ 높은 접근성
- ✅ AI 프롬프트 최적화

### 2.3 Two-Track 전략

#### Track 1: 보편적 압축 (범용 기술)
**기술 스택**:
- RAG (Retrieval-Augmented Generation)
- Semantic Chunking
- Vector DB (임베딩 기반 검색)

**장단점**:
- ✅ 검증된 기술
- ✅ 빠른 적용 가능
- ❌ 기술적 차별화 어려움
- ❌ 경쟁 많음

#### Track 2: 특수 압축 ⭐ **핵심 차별화**
**기술**: FPGA Graph RAG (하드웨어 특화 그래프 RAG)

**핵심 아이디어**:
1. 전체 프로젝트를 **종속성 그래프**로 변환
2. 사용자 질의/요청에 따라 **관련 부분만 추출**
3. 추출된 서브그래프만 AI에 전달

**예시**:
```
사용자: "clk_divider 모듈의 버그 찾아줘"
시스템:
  1. 종속성 그래프에서 clk_divider 노드 찾기
  2. 2-hop 이내 연결된 노드들 추출
     - clk_divider 모듈 코드
     - 이 모듈을 사용하는 상위 모듈
     - 이 모듈이 사용하는 하위 모듈/신호
  3. XDC에서 clk_divider 관련 제약만 추출
  4. 타이밍 리포트에서 이 모듈 경로만 추출
  5. 압축된 컨텍스트를 AI에 전달
```

## 3. 기술적 핵심 과제

### 3.1 종속성 그래프 구축

#### 일반 소프트웨어 (쉬움)
- SDK로 AST 파싱
- .NET Roslyn으로 종속성 추출
→ **이것만으로는 경쟁력 없음**

#### 우리의 차별화 포인트
1. **비표준 파일 지원**:
   - XDC (제약 파일) → 어떤 신호/모듈에 제약이 걸렸는지
   - BD (블록 디자인) → IP 블록 간 연결
   - .rpt (타이밍 리포트) → 어떤 경로가 크리티컬한지

2. **그래프 탐색 전략**:
   - **시작점 결정**: 어떤 노드부터?
   - **깊이 결정**: 몇 hop까지?
   - **선택성**: 어떤 종류의 엣지를 따를 것인가?

3. **컨텍스트 최소화**:
   - 버추얼 메모리 기법
   - 캐시 방식 (한번 로딩한 부분 재사용)

### 3.2 그래프 시작점과 깊이 결정

**방법 1: LLM 자동 결정**
```
사용자 질의 → LLM이 의도 파악 → 시작점/깊이 자동 설정
```
- 장점: 사용자 편의
- 단점: LLM 비용, 오판 가능성

**방법 2: 사용자 커스터마이징**
```
UI에서 설정:
- 종속성 깊이: 낮음(1-hop) / 중간(2-hop) / 깊음(3-hop)
- 시작 코드/파일 직접 선택
```
- 장점: 정확성, 제어 가능
- 단점: 학습 곡선

**제안**: 하이브리드
- 기본: 휴리스틱 자동 설정
- 고급 사용자: 수동 조정 가능

### 3.3 .v 파일의 유리한 점
- **높은 종속성**: 모듈 간 연결이 명확
- **정적 구조**: 동적 변화 없음
- **파싱 용이**: 표준화된 문법

## 4. 부가 가치: 그래프 시각화

### 4.1 AI 없이도 유용한 이유
프로젝트를 그래프로 보여주는 것 자체가 가치:
- 전체 구조 한눈에 파악
- 종속성 추적
- 병목 지점 발견
- 설계 리뷰 도구

### 4.2 기존 도구와의 차이
| 도구 | 제공 정보 | 한계 |
|------|----------|------|
| Vivado Schematic | 넷리스트 구조 | 계층 구조 파악 어려움 |
| 코드 에디터 | 텍스트 검색 | 시각적 연결 X |
| **우리 도구** | **계층적 그래프** | ✅ 직관적 탐색 |

## 5. 기술 로드맵

### Phase 1: 코드 그래프
- Yosys로 .v/.sv 파싱
- 모듈 계층 구조 그래프 생성
- 신호 연결 추적

### Phase 2: 제약 통합
- XDC 파싱 → 클럭/타이밍 제약 연결
- BD 파싱 → IP 블록 통합

### Phase 3: 타이밍 분석
- .rpt 파싱 → 크리티컬 패스 표시
- 딜레이/슬랙 정보 시각화

### Phase 4: AI 통합
- 서브그래프 추출 엔진
- LLM 컨텍스트 생성기
- 프롬프트 최적화

## 6. 핵심 알고리즘: 종속성 추적

### 6.1 기본 구조
```
전체 프로젝트 → 거대한 종속성 그래프 G
사용자 요청 → 시작 노드 v, 깊이 d
추출 → BFS/DFS로 d-hop 이내 서브그래프 G'
```

### 6.2 최적화
1. **메모이제이션**: 자주 조회되는 서브그래프 캐싱
2. **증분 업데이트**: 코드 변경 시 전체 재파싱 X
3. **레이지 로딩**: 필요한 부분만 메모리 로드

### 6.3 확장성
- 대규모 프로젝트 (10만+ 라인)에서도 동작
- 메모리 효율적 그래프 표현
- 병렬 처리 가능한 설계

## 7. 학술적 기여 가능성

### 7.1 연구 주제
- "Graph RAG for Hardware Description Languages"
- "Context-Aware Code Compression for FPGA Development"
- "Dependency Graph Pruning Strategies for AI-Assisted RTL Design"

### 7.2 특허 전략
- 종속성 그래프 구축 방법
- 서브그래프 추출 알고리즘
- XDC/BD 파일 그래프 통합 방법

## 8. 경쟁 기술 분석

### 8.1 기존 접근법
1. **전체 코드 전달**: 비효율적
2. **수동 선택**: 사용자 부담
3. **파일 단위 검색**: 종속성 무시

### 8.2 우리의 우위
- ✅ 자동화된 관련성 추출
- ✅ 구조적 정보 활용
- ✅ FPGA 특화 최적화

## 9. 기술적 도전과제

### 9.1 해결된 것
- ✅ 정적 구조 파싱 (Yosys)
- ✅ 기본 그래프 구축

### 9.2 해결해야 할 것
- ❓ XDC/BD 파싱 정확도
- ❓ 대규모 프로젝트 성능
- ❓ 최적 시작점/깊이 자동 결정
- ❓ AI와의 효과적인 인터페이스

### 9.3 장기 과제
- SystemVerilog 전체 지원
- 시뮬레이션 데이터 통합
- 실시간 협업 기능

## 10. 결론: 수렴 진화

> "Graph RAG의 텍스트 버전을 하드웨어에 적용하니, 신기한 수렴 진화"

- 텍스트용 Graph RAG와 독립적으로 같은 아이디어 도달
- 하지만 하드웨어 특성상 **더 잘 작동**
- 이는 기술적 타당성의 강력한 증거
